<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 来时路杂记</title>
        <link>http://localhost:1313/post/</link>
        <description>Recent content in Posts on 来时路杂记</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 02 Mar 2026 20:43:00 +0800</lastBuildDate><atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>First Shell</title>
            <link>http://localhost:1313/p/first-shell/</link>
            <pubDate>Mon, 02 Mar 2026 20:43:00 +0800</pubDate>
            <guid>http://localhost:1313/p/first-shell/</guid>
            <description>&lt;h1 id=&#34;missing-semester-class1&#34;&gt;Missing-Semester-Class1&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;本博客用于记录我对missing-semester的学习&lt;/p&gt;&#xA;&lt;h2 id=&#34;常用指令&#34;&gt;常用指令&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;date&#34;&gt;date&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;获取当前时间&lt;/p&gt;&#xA;&lt;h3 id=&#34;echo&#34;&gt;echo&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;把后面的第一个参数输出给终端&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; hello&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;上述代码将输出&lt;code&gt;hello&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$PATH&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;将咨询环境变量，找出路径，给出了echo指令的位置&lt;/p&gt;&#xA;&lt;h3 id=&#34;which&#34;&gt;which&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;找出执行指令的位置&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;which &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;输出：&lt;code&gt;/bin/echo&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;pwd&#34;&gt;pwd&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;输出当前工作目录&lt;/p&gt;&#xA;&lt;h3 id=&#34;cd&#34;&gt;cd&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;进入指定工作目录，其中&lt;code&gt;.&lt;/code&gt;表示进入当前这个目录，&lt;code&gt;..&lt;/code&gt;表示回到上一个目录&lt;/p&gt;&#xA;&lt;h3 id=&#34;ls&#34;&gt;ls&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;输出当前工作环境下所有文件与文件夹（不包含隐藏文件）&lt;/p&gt;&#xA;&lt;p&gt;如需输出隐藏文件需加后缀&lt;code&gt;-a&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;若需要详细列出文件与文件夹信息，使用后缀&lt;code&gt;-l&lt;/code&gt;，并且在后面加上文件名，获取指定文件信息&lt;/p&gt;&#xA;&lt;h3 id=&#34;man&#34;&gt;man&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;获取对应指令的详细操作手册&lt;/p&gt;&#xA;&lt;h3 id=&#34;cat&#34;&gt;cat&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于输出文件内容&lt;/p&gt;&#xA;&lt;h3 id=&#34;sudo&#34;&gt;sudo&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;放在指令前，赋予根用户权限&lt;/p&gt;&#xA;&lt;h3 id=&#34;chmod&#34;&gt;chmod&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;给文件改变权限&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod +x filename&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;使文件具有可执行权限&lt;/p&gt;&#xA;&lt;h3 id=&#34;touch&#34;&gt;touch&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;更新文件的修改时间为现在的时间，如若文件不存在，则创建一个新文件&lt;/p&gt;&#xA;&lt;h2 id=&#34;一些小知识点&#34;&gt;一些小知识点&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;heading&#34;&gt;&amp;gt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于把前面的内容存储到后面的文件中&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; hello &amp;gt; hello.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;可以把&lt;code&gt;hello&lt;/code&gt;写入文件&lt;/p&gt;&#xA;&lt;h3 id=&#34;heading-1&#34;&gt;&amp;lt;&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于把文件内容进行输出&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat &amp;lt; hello.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;把文件的内容输出出来&lt;/p&gt;&#xA;&lt;h3 id=&#34;heading-2&#34;&gt;|&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;把前面的指令的输出塞到后面程序的输入里面&lt;/p&gt;&#xA;&lt;h3 id=&#34;一些特殊的符号若要写入文件需要用单引号包住双引号不行&#34;&gt;一些特殊的符号若要写入文件需要用单引号包住，双引号不行&#xD;&#xA;&lt;/h3&gt;</description>
        </item><item>
            <title>我的第一本算法书笔记</title>
            <link>http://localhost:1313/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
            <pubDate>Sat, 21 Feb 2026 20:50:13 +0800</pubDate>
            <guid>http://localhost:1313/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
            <description>&lt;h1 id=&#34;第一本算法书--笔记整理&#34;&gt;第一本算法书 · 笔记整理&#xD;&#xA;&lt;/h1&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;目录&#34;&gt;目录&#xD;&#xA;&lt;/h2&gt;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%ae%97%e6%b3%95%e6%a6%82%e8%a7%88&#34; &gt;算法概览&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34; &gt;数据结构&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95&#34; &gt;排序算法&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%95%b0%e7%bb%84%e7%9a%84%e6%9f%a5%e6%89%be&#34; &gt;数组的查找&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%9b%be%e7%9a%84%e6%90%9c%e7%b4%a2&#34; &gt;图的搜索&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%ae%89%e5%85%a8%e7%ae%97%e6%b3%95&#34; &gt;安全算法&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e8%81%9a%e7%b1%bb&#34; &gt;聚类&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%85%b6%e4%bb%96%e7%ae%97%e6%b3%95&#34; &gt;其他算法&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;算法概览&#34;&gt;算法概览&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：把每一个步骤需要完成的时间设置为一个 T，再计算总共的时间，取对时间影响最大的部分，即为时间复杂度。它是用于描述算法运行时间的函数。&lt;/p&gt;&#xA;&lt;p&gt;例如，对于双重循环结构，会随输入 $n$ 变化的只有 $n$，因此时间复杂度为 $O(n^2)$。&lt;/p&gt;&#xA;&lt;img src=&#34;img/image1.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：决定数据顺序和位置关系的结构。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;h3 id=&#34;链表&#34;&gt;链表&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;数据呈线性排列，&lt;strong&gt;添加与删除均方便，但访问较耗时&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一个数据都有一个指针，指向下一个数据的内存地址（最后一个数据的指针不指向任何位置）&lt;/li&gt;&#xA;&lt;li&gt;数据分散存储在内存中&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;顺序访问&lt;/strong&gt;：要想访问数据，必须从第一个数据开始依次往下访问&lt;/li&gt;&#xA;&lt;li&gt;添加数据时，只需改变位置前后的指针指向即可，删除同理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;操作&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;访问数据&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;必须从头遍历&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;添加/删除&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;只需改变指针，与 $n$ 无关&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;strong&gt;扩展链表：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;循环链表&lt;/strong&gt;：用于保存数量固定的最新数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：设置前后两个指针，可双向遍历&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缺点：指针增加导致存储空间需求上升；添加/删除数据时需要改变更多指针&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;数组&#34;&gt;数组&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;数据存储在&lt;strong&gt;连续内存空间&lt;/strong&gt;中，可直接通过下标算出地址（即&amp;quot;随机访问&amp;quot;）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;添加或删除数据很复杂：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;需要确保数组末尾有足够的存储空间&lt;/li&gt;&#xA;&lt;li&gt;把后面的数据逐一往后移动&lt;/li&gt;&#xA;&lt;li&gt;在空出的位置写入新数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;操作&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;访问数据&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;添加/删除&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;strong&gt;链表与数组对比：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;访问&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;添加&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;删除&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;链表&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;慢&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;快&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;快&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;数组&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;快&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;慢&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;慢&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;img src=&#34;img/image2.png&#34; /&gt;&#xA;&lt;h3 id=&#34;栈&#34;&gt;栈&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;数据呈线性排列，但&lt;strong&gt;只能访问最新添加的数据&lt;/strong&gt;（类似一个桶，只能取最上面的元素）。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加数据：&lt;strong&gt;入栈&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;取出数据：&lt;strong&gt;出栈&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;访问规则：&lt;strong&gt;后进先出（LIFO，Last In First Out）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;队列&#34;&gt;队列&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;线性排列的数据结构，添加与取出操作分别在两端进行，可以想象成排成一列的人。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加数据：&lt;strong&gt;入队&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;取出数据：&lt;strong&gt;出队&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;访问规则：&lt;strong&gt;先进先出（FIFO，First In First Out）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;哈希表&#34;&gt;哈希表&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;存储由**键（Key）和值（Value）**组成的数据。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;存入数据：&lt;/strong&gt; 使用哈希函数计算键的哈希值，再取余（数组长度）得到存储位置，若发生冲突则在对应位置使用链表。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;取出数据：&lt;/strong&gt; 同样先计算哈希值并取余，找到对应位置，若不匹配则在链表中继续查找。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;利用哈希函数可以快速访问目标数据。如果发生哈希冲突，则使用链表存储，可灵活应对任意数据量。需注意数组空间的合理设置——空间太小容易发生冲突，太大则造成内存浪费。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;解决冲突的方法：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;链地址法&lt;/strong&gt;：在冲突位置使用链表存储多个数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;开放地址法&lt;/strong&gt;：冲突发生时计算出候补地址，将数据存入候补位置&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;堆&#34;&gt;堆&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;一种&lt;strong&gt;树形数据结构&lt;/strong&gt;，可用于实现优先队列。可自由添加数据，但取出数据时按最小值顺序取出。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;结构特点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各顶点称为&lt;strong&gt;结点（Node）&lt;/strong&gt;，数据存储于结点中&lt;/li&gt;&#xA;&lt;li&gt;每个结点最多有两个子结点，排列顺序为从上到下、从左到右&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;子结点的值必须大于父结点&lt;/strong&gt;，即根结点始终存储最小值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image3.png&#34; /&gt;&#xA;&lt;p&gt;&lt;strong&gt;操作流程：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;添加&lt;/strong&gt;：若新结点违反大小规则，则与父结点交换，直到满足条件&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;取出&lt;/strong&gt;：取走根结点后，将最后一个结点移到顶端，再重新调整堆结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;操作&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;取出最小值&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(1)$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;添加 / 重构&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(\log n)$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;二叉查找树&#34;&gt;二叉查找树&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;树形数据结构，每个结点最多有两个子结点。&lt;/p&gt;&#xA;&lt;img src=&#34;img/image4.png&#34; /&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心性质：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个结点的值&lt;strong&gt;大于&lt;/strong&gt;其左子树上任意结点的值&lt;/li&gt;&#xA;&lt;li&gt;每个结点的值&lt;strong&gt;小于&lt;/strong&gt;其右子树上任意结点的值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;常见操作：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;操作&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;方法&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;查找最小值&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;从顶端一路向左下末端查找&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;查找最大值&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;从顶端一路向右下末端查找&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;添加数据&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;从顶端比较大小，小则左移，大则右移，新元素必在末端&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;查找数据&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;从上到下按大小关系比较，大于则找右边，小于则找左边&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;strong&gt;删除数据：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无子结点：直接删除&lt;/li&gt;&#xA;&lt;li&gt;有一个子结点：将子结点移到被删除结点的位置&lt;/li&gt;&#xA;&lt;li&gt;有两个子结点：在左子树中找到最大结点，移到被删除结点的位置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt; 取决于树的高度&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;树形均衡时：$O(\log n)$&lt;/li&gt;&#xA;&lt;li&gt;树向单侧纵向伸展时：$O(n)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;扩展结构：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;平衡二叉查找树&lt;/strong&gt;：修正不均衡的树形，提高查找效率&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;B 树&lt;/strong&gt;：子结点数扩展为 $m$，子结点数可任意设定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image5.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;排序算法&#34;&gt;排序算法&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;冒泡排序&#34;&gt;冒泡排序&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;比较相邻两个元素，若左边大于右边则交换，按顺序重复比较。每一轮排序能保证一个元素到达正确位置，共需 $n-1$ 轮。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时间复杂度：$O(n^2)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;选择排序&#34;&gt;选择排序&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;使用线性查找找出最小值，将其与最左边的元素交换，共需查找 $n-1$ 次。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时间复杂度：$O(n^2)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;插入排序&#34;&gt;插入排序&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;取出一个数据，与其左边的数字依次比较：若左边数字更小则停止，否则继续向左比较并插入到合适位置。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时间复杂度：$O(n^2)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;堆排序&#34;&gt;堆排序&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;将所有数据存入堆中，按&lt;strong&gt;降序&lt;/strong&gt;（根结点最大）构建堆，依次取出根结点完成排序。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;注意：这里的堆根结点最大，与之前&amp;quot;取最小值&amp;quot;的堆方向相反，但同样符合堆的性质。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;插入 $n$ 个数据：$O(n \log n)$（每次插入 $O(\log n)$，共 $n$ 次）&lt;/li&gt;&#xA;&lt;li&gt;取出并重构：$O(\log n)$，共 $n$ 轮，总计 $O(n \log n)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：堆中最后一行有超过一半的数据，这部分的时间仅需 $\frac{1}{2}\log n$，在大 $O$ 记法中忽略常数，整体仍为 $O(n \log n)$。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 堆是复杂的数据结构，实现难度较高。&lt;/p&gt;&#xA;&lt;img src=&#34;img/image6.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;归并排序&#34;&gt;归并排序&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;将序列不断拆分成等长的两个子序列，直到每个子序列仅剩一个元素，再逐层合并（将两个有序子序列合并为一个有序序列）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;合并多个数字的子序列：&lt;/strong&gt; 比较两个子序列的首位数字，移动较小的数字到结果序列，再继续比较。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;时间分析：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一行的数据量均为 $n$，处理时间为 $O(n)$&lt;/li&gt;&#xA;&lt;li&gt;共有 $\log_2 n$ 行&lt;/li&gt;&#xA;&lt;li&gt;总时间复杂度：$O(n \log n)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image7.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;快速排序&#34;&gt;快速排序&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;从序列中随机选择一个&lt;strong&gt;基准值（pivot）&lt;/strong&gt;，将其余数据分为&amp;quot;小于基准值&amp;quot;和&amp;quot;大于基准值&amp;quot;两组：&lt;/p&gt;&#xA;$$[\text{比基准值小的数}] \quad \text{基准值} \quad [\text{比基准值大的数}]$$&lt;p&gt;对两侧的子序列递归地继续快速排序（&lt;strong&gt;分治法&lt;/strong&gt;），直到子序列只剩一个元素时排序完成。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;时间分析：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每行每个数字都需与基准值比较，时间为 $O(n)$&lt;/li&gt;&#xA;&lt;li&gt;若每次基准值均能将序列对半分，共有 $\log_2 n$ 行&lt;/li&gt;&#xA;&lt;li&gt;最优/平均时间复杂度：$O(n \log n)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image8.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;数组的查找&#34;&gt;数组的查找&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;线性查找&#34;&gt;线性查找&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;从头开始依次检查数据，直到找到目标。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时间复杂度：$O(n)$&lt;/li&gt;&#xA;&lt;li&gt;适用场景：&lt;strong&gt;添加频繁&lt;/strong&gt;或数据未排序时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;二分查找&#34;&gt;二分查找&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;比较数组&lt;strong&gt;中间&lt;/strong&gt;数据与目标数据的大小，每次将查找范围缩小一半。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时间复杂度：$O(\log n)$&lt;/li&gt;&#xA;&lt;li&gt;前提：数据必须&lt;strong&gt;已排好序&lt;/strong&gt;，添加数据时需插入合适位置&lt;/li&gt;&#xA;&lt;li&gt;适用场景：&lt;strong&gt;查找频繁&lt;/strong&gt;时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;算法&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;时间复杂度&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;要求&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;线性查找&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(n)$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;二分查找&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$O(\log n)$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;数据已排序&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;图的搜索&#34;&gt;图的搜索&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;什么是图&#34;&gt;什么是图&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;由&lt;strong&gt;顶点&lt;/strong&gt;和连接每对顶点的&lt;strong&gt;边&lt;/strong&gt;所构成的图形。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;加权图&lt;/strong&gt;：给边加上权重（表示顶点间的连接程度，如距离、费用等）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image9.png&#34; /&gt;&#xA;&lt;img src=&#34;img/image10.png&#34; /&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;：边带有方向（箭头），只能单向行驶；无箭头则为无向图；有向图的边也可以设置非对称权重&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image11.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;广度优先搜索bfs&#34;&gt;广度优先搜索（BFS）&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;从起点出发，&lt;strong&gt;优先搜索距离起点近的顶点&lt;/strong&gt;，由近及远扩展。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;过程：&lt;/strong&gt; 从起点开始，将相邻顶点加入候补队列；搜索完附近的点后，从队列中取出最早加入的候补顶点继续搜索。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;候补顶点用&lt;strong&gt;先入先出（FIFO）&lt;strong&gt;方式管理，可用&lt;/strong&gt;队列&lt;/strong&gt;数据结构实现。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;特征：&lt;/strong&gt; 目标顶点离起点越近，搜索越快；适合寻找&lt;strong&gt;最短路径&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;图若没有闭环，则称为&lt;strong&gt;树&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;深度优先搜索dfs&#34;&gt;深度优先搜索（DFS）&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;沿着一条路径&lt;strong&gt;不断往下搜索直到无法继续&lt;/strong&gt;，然后折返，再搜索下一条候补路径。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;过程：&lt;/strong&gt; 每次选择&lt;strong&gt;最新加入的&lt;/strong&gt;候补顶点作为下一步，一路向深处搜索。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;候补顶点采用&lt;strong&gt;后入先出（LIFO）&lt;strong&gt;方式管理，可用&lt;/strong&gt;栈&lt;/strong&gt;数据结构实现。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;BFS vs DFS 对比：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BFS 选择最早成为候补的顶点 → 由近及远搜索&lt;/li&gt;&#xA;&lt;li&gt;DFS 选择最新成为候补的顶点 → 沿路径一路深入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image12.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;贝尔曼-福特算法&#34;&gt;贝尔曼-福特算法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于求&lt;strong&gt;带权图的单源最短路径&lt;/strong&gt;，支持负权边。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;过程：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将起点权重设为 $0$，其余顶点设为无穷大&lt;/li&gt;&#xA;&lt;li&gt;遍历所有边，计算&amp;quot;该边一端顶点的权重 + 边的权重&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;若计算结果小于另一端顶点的当前值，则更新&lt;/li&gt;&#xA;&lt;li&gt;重复 $n$ 轮，最终留下的边即为最短路径&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt; $O(nm)$（$n$ 为顶点数，$m$ 为边数）&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：若图中存在权重和为负的环（负权环），则不存在最短路径，因为可以无限循环使路径权重不断减小。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;狄克斯特拉算法&#34;&gt;狄克斯特拉算法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于求&lt;strong&gt;不含负权边的带权图的单源最短路径&lt;/strong&gt;，比贝尔曼-福特更高效。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;过程：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将起点权重设为 $0$，其余顶点设为无穷大&lt;/li&gt;&#xA;&lt;li&gt;从当前顶点可直达且未被搜索的顶点中，选出候补顶点并更新权重&lt;/li&gt;&#xA;&lt;li&gt;选择候补顶点中&lt;strong&gt;权重最小&lt;/strong&gt;的顶点作为下一步顶点&lt;/li&gt;&#xA;&lt;li&gt;重复以上过程，直到到达终点&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无优化：$O(n^2)$&lt;/li&gt;&#xA;&lt;li&gt;对数据结构优化（如使用优先队列）：$O(m + n \log n)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：含负权边时可能无法得出正确答案，此时应使用贝尔曼-福特算法。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;a-算法&#34;&gt;A* 算法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;在狄克斯特拉算法基础上引入&lt;strong&gt;启发信息&lt;/strong&gt;，加速搜索过程。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心思路：&lt;/strong&gt; 预先估算各顶点到终点的距离，将&amp;quot;起点到当前顶点的实际距离 + 当前顶点到终点的估算距离&amp;quot;作为优先级依据，每次选择该值最小的顶点继续搜索。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;安全算法&#34;&gt;安全算法&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;传输数据的四大安全问题与应对措施&#34;&gt;传输数据的四大安全问题与应对措施&#xD;&#xA;&lt;/h3&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;问题&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;应对措施&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;窃听&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;加密技术&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;假冒&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;消息认证码、数字签名&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;篡改&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;消息认证码、数字签名&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;事后否认&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;数字签名&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;加密基础知识&#34;&gt;加密基础知识&#xD;&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;加密&lt;/strong&gt;：利用密钥对数据进行数值运算，将数据转变为第三方无法理解的形式（密文）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;解密&lt;/strong&gt;：利用密钥对密文进行计算，将其恢复为原始数据&lt;/li&gt;&#xA;&lt;li&gt;所有数据（文本、音频、图像）在计算机中均以二进制表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;哈希函数&#34;&gt;哈希函数&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;将任意输入数据转换为&lt;strong&gt;固定长度&lt;/strong&gt;的无规律数值（哈希值），常用十六进制表示，可作为数据摘要。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;主要特性：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;输入相同 → 输出必然相同（同一算法下）&lt;/li&gt;&#xA;&lt;li&gt;输入相似 → 输出哈希值不相似&lt;/li&gt;&#xA;&lt;li&gt;不同输入可能产生相同哈希值（&lt;strong&gt;哈希冲突&lt;/strong&gt;，概率极低）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;不可逆&lt;/strong&gt;：无法从哈希值反推原始数据&lt;/li&gt;&#xA;&lt;li&gt;计算哈希值的运算相对容易&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;常用算法：&lt;/strong&gt; MD5、SHA-1、SHA-2（前两者存在安全隐患，推荐使用 SHA-2）&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;典型应用：&lt;/strong&gt; 密码存储。服务器不直接保存用户密码，而是保存其哈希值。用户登录时，计算输入密码的哈希值并与存储值比对，即使哈希值泄露，也无法反推出原始密码。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;共享密钥加密对称加密&#34;&gt;共享密钥加密（对称加密）&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;加密和解密使用&lt;strong&gt;相同的密钥&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;问题：密钥分配问题&lt;/strong&gt; —— 发送方需要将密钥安全地传递给接收方，而在互联网上传输密钥存在被窃听的风险。&lt;/p&gt;&#xA;&lt;p&gt;解决方案：密钥交换协议 / 公开密钥加密。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺陷：&lt;/strong&gt; 随着通信人数的增多，所需密钥数量急剧增加。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;公开密钥加密非对称加密&#34;&gt;公开密钥加密（非对称加密）&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;接收方生成一对密钥：&lt;strong&gt;公开密钥（公钥）&lt;/strong&gt; 和 &lt;strong&gt;私有密钥（私钥）&lt;/strong&gt;，将公钥发送给发送方。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送方使用&lt;strong&gt;公钥加密&lt;/strong&gt;数据&lt;/li&gt;&#xA;&lt;li&gt;接收方使用&lt;strong&gt;私钥解密&lt;/strong&gt;密文&lt;/li&gt;&#xA;&lt;li&gt;公钥无法解密密文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;常用算法：&lt;/strong&gt; RSA 算法、椭圆曲线加密算法（ECC）&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全隐患：中间人攻击&lt;/strong&gt; —— 攻击者可替换公钥，解密数据后再转发给接收方，双方均无法察觉。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt; 使用&lt;strong&gt;数字证书&lt;/strong&gt;验证公钥的合法性。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;额外问题：&lt;/strong&gt; 加密与解密十分耗时，不适合持续发送零碎数据，需使用&lt;strong&gt;混合加密&lt;/strong&gt;解决。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;加密算法的基本要求：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以用某个数值对数据进行加密计算&lt;/li&gt;&#xA;&lt;li&gt;使用另一个数值对加密数据进行计算可使数据恢复原样&lt;/li&gt;&#xA;&lt;li&gt;无法从一种密钥推算出另一种密钥&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;混合加密&#34;&gt;混合加密&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;结合共享密钥加密和公开密钥加密的优势：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用&lt;strong&gt;速度较快的共享密钥&lt;/strong&gt;对文件数据加密&lt;/li&gt;&#xA;&lt;li&gt;用&lt;strong&gt;安全的公开密钥&lt;/strong&gt;对共享密钥本身进行加密传输&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;流程（A 向 B 发送数据）：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B 生成公钥和私钥，将公钥发给 A&lt;/li&gt;&#xA;&lt;li&gt;A 用共享密钥加密数据&lt;/li&gt;&#xA;&lt;li&gt;A 用 B 的公钥对共享密钥加密，将加密后的密钥发给 B&lt;/li&gt;&#xA;&lt;li&gt;B 用私钥解密，获得共享密钥&lt;/li&gt;&#xA;&lt;li&gt;B 用共享密钥解密数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt; 兼具安全性与处理速度。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt; SSL/TLS 协议（为网络通信提供安全保障）即采用了混合加密方法。&lt;/p&gt;&#xA;&lt;img src=&#34;img/image13.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;迪菲-赫尔曼密钥交换&#34;&gt;迪菲-赫尔曼密钥交换&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;通过将双方共有的秘密数值&lt;strong&gt;隐藏在公开数值的运算中&lt;/strong&gt;，安全地交换密钥，无需预先共享秘密。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;数学本质：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A 准备素数 $P$ 和生成元 $G$，发送给 B&lt;/li&gt;&#xA;&lt;li&gt;A 和 B 分别准备各自的秘密数字 $X$ 和 $Y$（均小于 $P-2$）&lt;/li&gt;&#xA;&lt;li&gt;A 计算 $G^X \mod P$，B 计算 $G^Y \mod P$，双方将结果互相发送&lt;/li&gt;&#xA;&lt;li&gt;A 计算 $(G^Y \mod P)^X \mod P$，B 计算 $(G^X \mod P)^Y \mod P$，双方得到相同结果&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全性基础：&lt;/strong&gt; 由 $P$、$G$ 和 $G^X \mod P$ 求出 $X$，即&amp;quot;&lt;strong&gt;离散对数问题&lt;/strong&gt;&amp;quot;，目前无法高效求解。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;消息认证码mac&#34;&gt;消息认证码（MAC）&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于实现&lt;strong&gt;认证&lt;/strong&gt;和&lt;strong&gt;检测篡改&lt;/strong&gt;功能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; 发送方使用密文和密钥生成 MAC 值并一同发送；接收方用同样的密钥和密文计算 MAC 值，比较两者是否一致以判断是否被篡改。&lt;/p&gt;&#xA;&lt;p&gt;MAC 可看作是由密钥和密文组成的字符串的&amp;quot;哈希值&amp;quot;，常用算法有 HMAC、OMAC、CMAC 等（目前 HMAC 应用最广泛）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 通信双方都能生成 MAC，无法确定信息的来源（即无法防止否认），此问题由&lt;strong&gt;数字签名&lt;/strong&gt;解决。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;数字签名&#34;&gt;数字签名&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;在消息认证码的基础上，还可解决&lt;strong&gt;事后否认&lt;/strong&gt;问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;流程（A 向 B 发送签名消息）：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A 将公钥发送给 B&lt;/li&gt;&#xA;&lt;li&gt;A 使用&lt;strong&gt;私钥&lt;/strong&gt;对消息（或消息的哈希值）进行加密，生成&lt;strong&gt;数字签名&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;A 将消息和签名一同发送给 B&lt;/li&gt;&#xA;&lt;li&gt;B 使用 A 的&lt;strong&gt;公钥&lt;/strong&gt;对签名解密，与收到的消息进行比对&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xD;&#xA;    &lt;blockquote&gt;&#xD;&#xA;        &lt;p&gt;这与公开密钥加密的流程相反：加密时用私钥，解密时用公钥。&lt;/p&gt;&#xA;&#xD;&#xA;    &lt;/blockquote&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;时间优化：&lt;/strong&gt; 由于加解密耗时，实际上通常是对消息的&lt;strong&gt;哈希值&lt;/strong&gt;进行签名，而非消息本体。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 无法确认公钥的真正持有者，可能被冒充，此问题由&lt;strong&gt;数字证书&lt;/strong&gt;解决。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;数字证书&#34;&gt;数字证书&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;通过权威的**认证中心（CA，Certification Authority）**验证公钥的合法性。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;流程：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A 向 CA 提交公钥及个人资料（如邮箱）&lt;/li&gt;&#xA;&lt;li&gt;CA 核实后，用自己的私钥对 A 的资料生成数字签名&lt;/li&gt;&#xA;&lt;li&gt;CA 将签名和资料合并为&lt;strong&gt;数字证书&lt;/strong&gt;，发给 A&lt;/li&gt;&#xA;&lt;li&gt;A 将证书发给 B&lt;/li&gt;&#xA;&lt;li&gt;B 从 CA 获取公钥，验证证书上的签名是否来自 CA&lt;/li&gt;&#xA;&lt;li&gt;验证通过后，B 从证书中提取 A 的公钥&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;CA 本身的合法性由更高级的 CA 签名保证，形成&lt;strong&gt;信任链&lt;/strong&gt;；根 CA 通常与政府关联，具有社会公信力。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网站的证书称为&lt;strong&gt;服务器证书&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;数字证书的一系列技术规范称为&lt;strong&gt;公钥基础设施（PKI）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;img src=&#34;img/image14.png&#34; /&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;聚类&#34;&gt;聚类&#xD;&#xA;&lt;/h2&gt;&lt;p&gt;将相似的对象分为一组，&lt;strong&gt;相似程度&lt;/strong&gt;通常用两组数据所表示的点之间的&lt;strong&gt;欧几里得距离的平方&lt;/strong&gt;来衡量。&lt;/p&gt;&#xA;&lt;h3 id=&#34;k-means-算法&#34;&gt;k-means 算法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;将数据按要求分为 $k$ 个簇。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;随机选点&lt;/strong&gt;：随机选择 $k$ 个点作为簇的初始中心点&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;计算距离&lt;/strong&gt;：计算每个数据点与各中心点的距离，将其归入最近的簇&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;更新中心点&lt;/strong&gt;：计算各个簇的重心，将中心点移动到重心位置&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;重复执行&lt;/strong&gt;：重新划分簇，直到中心点不再变化为止&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;层次聚类算法&#34;&gt;层次聚类算法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;初始时每个数据自成一个独立的簇，不断将距离最近的两个簇合并，直到满足条件。&lt;/p&gt;&#xA;&lt;p&gt;需要预先定义&amp;quot;簇与簇之间的距离&amp;quot;的计算方式。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;其他算法&#34;&gt;其他算法&#xD;&#xA;&lt;/h2&gt;&lt;h3 id=&#34;欧几里得算法&#34;&gt;欧几里得算法&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;用于计算两个数的&lt;strong&gt;最大公约数（GCD）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用较小的数去除较大的数，求余数（mod 运算）&lt;/li&gt;&#xA;&lt;li&gt;再用除数和余数继续进行 mod 运算&lt;/li&gt;&#xA;&lt;li&gt;重复以上操作，直到余数为 $0$&lt;/li&gt;&#xA;&lt;li&gt;最后一个不为 $0$ 的余数即为最大公约数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;素性测试&#34;&gt;素性测试&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;判断一个数是否为素数，利用&lt;strong&gt;费马小定理&lt;/strong&gt;：&lt;/p&gt;&#xA;$$\text{若 } p \text{ 为素数，则对任意 } n &lt; p，有  n^p \equiv n \pmod{p}$$&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt; 随机选择若干个小于测试数的整数 $n$，分别计算 $n^p \mod p$，若结果均等于 $n$，则判定该数为素数（概率性判断）。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;网页排名pagerank&#34;&gt;网页排名（PageRank）&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;在搜索网页时对搜索结果进行排序的算法，&lt;strong&gt;链入页面越多的网页，重要性越高&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心规则：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个网页的权重等于所有链入页面的权重之和&lt;/li&gt;&#xA;&lt;li&gt;若一个页面链向多个页面，则该页面的权重由这些页面&lt;strong&gt;平分&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;当存在环状链接时，采用&lt;strong&gt;随机游走模型&lt;/strong&gt;：模拟用户随机点击链接的行为，记录每个网页被访问的次数，以此估算权重&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;汉诺塔&#34;&gt;汉诺塔&#xD;&#xA;&lt;/h3&gt;&lt;p&gt;经典的&lt;strong&gt;递归算法&lt;/strong&gt;。将 $n$ 个盘子从 A 柱移到 C 柱（借助 B 柱）的策略：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先将上面 $n-1$ 个盘子移到辅助柱&lt;/li&gt;&#xA;&lt;li&gt;再将最大的盘子移到目标柱&lt;/li&gt;&#xA;&lt;li&gt;最后将 $n-1$ 个盘子从辅助柱移到目标柱&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;最少移动次数：&lt;/strong&gt;&lt;/p&gt;&#xA;$$T(n) = 2^n - 1$$</description>
        </item><item>
            <title>我的第一篇博客</title>
            <link>http://localhost:1313/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
            <pubDate>Sat, 21 Feb 2026 18:30:19 +0800</pubDate>
            <guid>http://localhost:1313/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
            <description>&lt;h1 id=&#34;这是我的第一篇博客&#34;&gt;这是我的第一篇博客&#xD;&#xA;&lt;/h1&gt;&lt;p&gt;本博客在&lt;strong&gt;Claude&lt;/strong&gt;指导下搭建，我学会了Hugo的用法&lt;/p&gt;&#xA;&lt;p&gt;我将在这里记录我的学习日常&lt;/p&gt;&#xA;</description>
        </item></channel>
</rss>
